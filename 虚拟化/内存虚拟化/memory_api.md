# 14内存API

&ensp;&ensp;&ensp;&ensp;在这篇文章，我们将讨论UNIX系统下的内存分配接口,UNIX所提供的接口是相当简单的,因此这一章也会很短很切题,我们要解决的主要问题如下:

```Text
                       关键:如何分配和管理内存
    在UNIX/C程序，明白如何分配和管理内存对于构建鲁棒和可靠软件是至关重要的。
什么接口是我们经常使用的?什么样的错误我们应该避免？
```

## 14.1 内存的类型

&ensp;&ensp;&ensp;&ensp;在运行的C程序中,有两种分配的内存类型。第一种叫做**stack(栈)**内存,并且分配和释放它的空间是由编译器*隐性*的替我们(程序员)完成的;由于这个原因，有时也把栈内存叫做**自动**内存。

&ensp;&ensp;&ensp;&ensp;在C语言中在栈上声明内存是简单的,举个例子,我们需要在函数`func()`中有一个存放整数x的地方。为了声明这么一片内存,我们只需要像下面这样做:

```c
void func() {
    int x;  // 在栈上声明一个整数
    // do something
}
```

&ensp;&ensp;&ensp;&ensp;当我们调用了`func()`,编译器做了余下的工作,确保在栈上有那么一块空间供变量x使用.但我们从函数返回,这个编译器也会为我们释放掉这块内存;因此,如果你想要在函数调用后留下一些数据(该变量不会随着函数调用结束而释放),你最好别把让该数据位于栈内存上.

&ensp;&ensp;&ensp;&ensp;正是这种对生命周期长的内存由需求,我们由第二种内存类型,叫做**heap(堆)**内存,它在内存中的分配和释放全都由我们程序员手动管理。无疑这是责任重大的!并且很可能会造成bugs.但是如果你是仔细的且多加留意,你将会正确的使用这些接口并且并不会有太多麻烦.这又一个例子，我们如何分配一个指向在堆内存上的整数的指针.

```c
#include <stdlib.h>
void func() {
    int *x = (int x) malloc(sizeof(int));
    // do something.
}
```

&ensp;&ensp;&ensp;&ensp;上面这代码块需要一些注解.首先,你可能注意到在栈和堆上分配空间在同一行:首先编译器知道需要给指向整数的指针分配一块空间正如我们所看到的指针的声明(int *x);随后，当程序调用`malloc()`,它在堆上请求了一块空间;操作系统返回给它给整数的地址(取决于成功与否,失败返回NULL),该地址存储在栈上由我们的程序所用.

&ensp;&ensp;&ensp;&ensp;由于堆内存的显式特性，以及其使用的多样性，堆内存给用户和系统都带来了更多的挑战。因此，这是我们接下来讨论的重点。

## 14.2 `malloc()`调用

&ensp;&ensp;&ensp;&ensp;调用`malloc()`是相当简单的:你给`malloc()`传递大小作为参数,在堆上申请这么一块空间,然后要么成功给你返回一个指向新分配空间的首地址,或者申请失败返回NULL.

&ensp;&ensp;&ensp;&ensp;输入`man malloc`我们能够在命令行看到如下输出:

```c
#include<stdlib.h>
...
void *malloc(size_t size);
```

&ensp;&ensp;&ensp;&ensp;从上面的输出我们能够了解到我们需要做的是引入头文件`stdlib.h`以便使用`malloc()`.事实上,你甚至不需要这么做,因为所有C程序默认链接的C库中都有malloc()的代码;引入该头文件仅仅是让编译器检查是否你正确地调用了`malloc()`(譬如，是否了传递正确类型的参数进去)

&ensp;&ensp;&ensp;&ensp;`malloc()`只需要一个size_t类型的值作为参数,该参数描述了你需要多少字节的空间.然而,大多数程序员在调用`malloc()`时并不直接传入一个数字作为参数(例如10);的确，这样做会被认为是缺少信息的.相反,我们可以利用多种宏.例如,去分配一个双精度的浮点数,我们可以这么做

```c
double *d = (double *) malloc(sizeof(double));
```

```Text
                小贴士:当有疑问时，试一试
    如果您不确定正在使用的某个例程(routine)或操作符的行为方式，没有什么可以替代简单地尝试它，并确保它的行为符合您的期望。虽然阅读手册页或其他文档是有用的，但它在实践中如何工作才是重要的。编写一些代码并测试它!毫无疑问，这是确保代码按照您的意愿运行的最佳方法。实际上，这就是我们所做的，以再次检查我们所说的关于sizeof()的内容是否真实!
```

&ensp;&ensp;&ensp;&ensp;`malloc()`使用`sizeof()`操作符去请求合适的内存空间大小;在c语言中,这一般把他视为*编译期compile-time*操作符,以为这实际上所申请的内存大小在*编译期*就已经知道了,并且由于是双精度浮点数(在上面的例子中,8)被替换然后作为参数传给`malloc()`.由于这个原因，`sizeof`被认为是一个操作符而不是函数调用(函数调用发生在运行时)

&ensp;&ensp;&ensp;&ensp;你也可以传递一个变量名作为`sizeof()`的参数,但是这样的话你可能会得到与期望不符的结果.举个例子,让我们看下面的代码片段:

```c
int *x = malloc(10 * sizeof(int));
printf("%d\n", sizeof(x));
```

在第一行,我们为一个包含十个整数的数组声明一块空间,这是令人满意的(fine and dandy).然而,但我们在下一行使用`sizeof()`,它返回的是一个比较小的值,例如4(在32位机器上)或者8(在64位机器上).这些原因是因为,`sizeof()`认为我们仅仅是在询问指向一个整数的指针要多大,并不是我们动态分配的内存大小(这一块内容看到后面的Free-Space Management会更好理解).然而,有些时候`sizeof()`会像我们期望一般工作:

```c
int x[10];
printf("%d\n", sizeof(x));
```

&ensp;&ensp;&ensp;&ensp;在这种情况下,这又足够多的静态信息去帮助编译器知道需要40字节的空间去分配.

&ensp;&ensp;&ensp;&ensp;另一个值得注意的地方是和字符串"打交道".当我们声明一块空间给字符串,使用下面的惯例(idiom)方法:`malloc(strlen(s) + 1)`,其中`strlen()`函数会返回字符串的长度,加1是为了给字符串的终止字符腾出位置.因此仅仅分配字符串长度大小的空间可能会导致未期望行为.

&ensp;&ensp;&ensp;&ensp;你或许已经注意到了`malloc()`的返回的指针类型是`void`.这样做只是在C语言中传递一个地址并让程序员决定如何处理它的方法。程序员通过使用所谓的**强制转换cast**进一步方便使用;在我们上面的例子,程序员把`malloc()`的返回值强制转换为`double *`类型.强制类型转换并不会真正的完成什么,他只是告诉编译器和其它可能会看你代码的程序员说"嘿，我知道我正在做的是什么".通过强制转换`malloc()`返回值的类型，程序员只是给了一些安慰;正确性不需要强制转换。

## 14.3 `free()`调用

&ensp;&ensp;&ensp;&ensp;事实证明，分配内存是这个等式中最简单的部分;知道何时，如何准确的释放内存是最难的部分.为了释放在堆上不再使用的内存,程序员简单的调用`free()`就可以:

```c
int *x = malloc(10 * sizeof(int));
...
free(x);
// 看到这里可能会好奇，为什么仅仅给我传个首地址，他却知道要释放多大的空间了？
// 答案在Free-Space Management章节中有说明
```

&ensp;&ensp;&ensp;&ensp;`free()`函数接收一个参数,一个由`malloc()`返回的指针.因此，你可能注意到，程序员并没有传递分配的空间大小，因此这必须有分配内存的库开追踪完成。

## 14.4 常见的错误

&ensp;&ensp;&ensp;&ensp;这有许多由于调用`malloc()`和`free()`而引发的大量错误,这有一些我们教学生操作系统这门课上一再看到的错误.所有这些例子都编译完成
并且从编译器中查看是否正常运行;虽然编译一个C程序对于构建一个正确的C程序是必要的，但是仅仅编译通过是远远不够的.

&ensp;&ensp;&ensp;&ensp;正确的内存管理一直以来都是一个问题,事实上,有很多新的语言支持**自动内存管理**.在这些语言中,当你调用类似于`malloc()`的函数去申请内存空间，你从来不需要去调用类似`free()`的函数去释放空间;相反,一个**垃圾回收程序**运行着并且指出那些内存是不再被引用的并且为你释放掉.

### 14.4.1 忘记分配内存

&ensp;&ensp;&ensp;&ensp;许多函数期望你在调用它之前已经分配好了内存空间,鞠个例子,`strcpy(dst, src)`函数服役一个字符串从原指针到目标指针.然而，如果你不注意，你可能会像下面这样做:

```c
char *src = "hello";
char *dst;  // 坏起来了，没有分配空间
strcpy(dst, src);  // 段错误并且程序终止
```

&ensp;&ensp;&ensp;&ensp;当你运行上面能够编译成功的代码，但是你会得到一个**段错误segmentation fault**,这是一个术语，意思是**你对内存做了错事，你个愚蠢的程序员，我很愤怒**

```Text
                贴士：编译或者能够运行!=他是正确的
    仅仅因为一个程序被编译(!)或者正确运行了一次或多次并不意味着这个程序是正确的。许多事件可能会合谋让你相信它是有效的，但随后一些事情发生了变化，它停止了。学生们普遍的反应是说(或喊)“但以前有用!”然后责怪编译器、操作系统、硬件，甚至(我们敢这么说)教授。但是问题通常出现在您认为正确的地方，在您的代码中。在指责之前，先着手工作并调试它。
```

&ensp;&ensp;&ensp;&ensp;在上面的例子中,正确的代码应该如下:

```c
char *src = "hello";
char *dst = (char *) malloc(strlen(src) + 1);
strcpy(dst, src);  // 正确工作
```

&ensp;&ensp;&ensp;&ensp;此外,你能够使用[strdup](https://www.geeksforgeeks.org/strdup-strdndup-functions-c/)使这件事变得简单,阅读`strdup`的手册获得更多信息。

### 14.4.2 没有分配足够的内存

&ensp;&ensp;&ensp;&ensp;一个类似的错误是没有分配足够的内存,有些时候叫做**buffer overflow缓冲区溢出**.在上面的例子中,一个普遍的错误使分配了*差不多足够*空间给目标字符串.

```c
char *src = "hello";
char *dst = (char *) malloc(strlen(src));  // 太小了，忘了字符串终止字符
strcpy(dst, src);
```

&ensp;&ensp;&ensp;&ensp;很奇怪是吧，这取决于malloc是如何执行的以及其他的一些细节,这个程序经常看似运行正确 .在某些情况下，当执行字符串复制，它写入的字节远远超过所分配空间的末尾，在某些情况下这是无害的，可能是覆盖了一个没用的变量.在某些情况下，这种溢出会导致错误,并且这实际上是很多系统中的安全漏洞的源头.在其他情况下，内存分配库可能会替你额外的分配终止字符的空间，因此你的程序不会覆盖别的变量值并且运行得很好.在最糟糕的情形下，你的程序可能会错误并且中断.并且我们上了另一个有价值的一堂课:即便他曾经能够正确的郧西，不代表他是正确的.

### 14.4.3 给分配的内存没有初始化

&ensp;&ensp;&ensp;&ensp;这种错误场景下,你调用`malloc()`没有问题,但是忘记了给你新分配得到的内存填充相应数据类型的值.不要这么做!如果你忘了,你的程序将会遇到一个`未初始化读取`，他从堆上读取一个不知道值的数据,谁能够知道会发生什么了？如果你是幸运的,一些值也能够使程序工作。如果不是，可能会出现随机的行为并且使有害的.

### 14.4.4 忘记释放内存

&ensp;&ensp;&ensp;&ensp;另一个常见的错误叫做**内存泄漏memory leak**,当你忘记释放内存时它就会出现.在长期运行的程序或者系统(例如操作系统),这是一个巨大的问题,因为缓慢的内存泄漏最终会导致用光内存,在这种情况下，重启是必须的.因此，一般来说，当你用完了一块内存，你应该确保释放掉它.注意使用垃圾回收的语言并不需要你来完成:如果你依然对一块内存有引用，垃圾回收程序并不会回收它，因此，即便在现代的语言，内存泄漏的问题也依然存在

&ensp;&ensp;&ensp;&ensp;注意并不是所有的内存搜需要释放，至少，在某些场合。举个例子，当你写了一个"短命(short-lived)"的程序,你可能会使用`malloc()`申请一些内存,这个程序运行并且快要 运行完了:是否有必要在程序退出之前调用多次`free()`？尽管不这么做似乎是错误的，但在这种情况下，简单地退出是相当不错的。毕竟，当你的程序退出，操作系统会清楚该进程的所有，包括所申请的一切内存.调用`free()`多次并且在退出可能意义并不大,并且，如果你做得不正确,可能会造成程序崩溃，只要调用退出就好*_*.

### 14.4.5 在你完活之前释放内存

&ensp;&ensp;&ensp;&ensp;有时一个程序会在完成使用之前会释放掉内存;例如错误的调用**悬垂指针dangling pointer**,正如你所猜测的,这是一件坏事。随后的使用可能会造成程序崩溃,或者覆盖掉合理的内存

### 14.4.6 重复释放内存

&ensp;&ensp;&ensp;&ensp;程序又是也会多次释放内存;这被叫做**重复释放double free**.这么做的结果时不确定的，正如你所想象，分配内存的库可能会困惑并且做出一些古怪的事;紧随其后的往往是程序崩溃.

### 14.4.7 错误的调用free()

&ensp;&ensp;&ensp;&ensp;我们要讨论的最后一个错误就是不正确的调用`free()`.毕竟，`free()`仅仅期望你传给她一个你之前调用`malloc()`所得到的返回值,当你传递一些其他值进去，一些不好的行为可能会发生.因此，例如**不合法释放invalid frees**是危险的并且应当避免.

### 14.4.8 总结

&ensp;&ensp;&ensp;&ensp;正如你所看到的，这有许多种滥用内存的方式。因为和内存的高频错误，已经开发了一整套工具来帮助您在代码中找到这些问题。查**purify**和**valgrind**去获取帮助;两者都能很好地帮助你找到与内存有关的问题的根源。一旦你习惯了使用这些强大的工具，你会想知道没有它们你是如何生存的。

## 14.5 底层操作系统的支持

&ensp;&ensp;&ensp;&ensp;你可能已经注意到了我们在讨论`malloc()`和`free()`的时候没有讨论系统调用.这个原因是简单的：他们不是系统调用,仅仅是库调用(library call).因此malloc库在你的虚拟地址空间中管理着内存空间,但是它本身是构建在一些系统调用之上,这些系统调用能够调用操作系统去要求更多的内存或者释放一些不需要的内存还给系统

&ensp;&ensp;&ensp;&ensp;这些中的一个系统调用是`brk`,他被用来更改程序中断(break)的位置:堆结束的位置(?为什么不是栈，地址空间自上往下不一般是code,heap和stack吗?).他接受一个参数(新中断的地址),随后增加或者减少堆的尺寸基于新中断点与当前中断点的大小关系.另外一个系统调用`sbrk`做相同的事，只是他只会增加中断点，否则一切照常。

&ensp;&ensp;&ensp;&ensp;注意你不应该直接调用`brk`或者`sbrk`。内存分配库使用他们;如果你试图使用他们,你可能会导致糟糕的事情发生.因此，调用`malloc()`和`free()`而不是直接调用`brk`和`sbrk`.

&ensp;&ensp;&ensp;&ensp;最后，你也可以通过`mmap()`调用从操作系统获取内存.通过传递正确的参数,`mmap()`能够为你的程序创建**匿名**内存区域-一个不和任何特别的文件所关联而只和**交换空间swap space**,交换空间我们会在后面的虚拟内存章节详细讨论.这块内存空间可以看成堆内存，翻阅有关`mmap()`的手册获取更多细节

## 14.6 其他的调用

&ensp;&ensp;&ensp;&ensp;这也有由内存分配库提供的其他调用。例如:`calloc()`分配内存并且相较于`malloc()`他会全部初始化为0;这预防了假设内存存放的是0并且忘记了初始化的错误(14.4.3).`realloc()`同样也是有用的,但你已经给某物(例如，一个数组)分配了空间,然后需要给他加一些空间:`realloc()`会创建一个更大的内存区域,并且复制之前的数据进去，然后返回指向新地址的指针。

## 14.7 总结

&ensp;&ensp;&ensp;&ensp;我们已经介绍了一些关于内存分配的API.一如往常，我们仅仅覆盖了一些基础;更多的细节需要自己去研究.读关于[C语言的书](https://en.wikipedia.org/wiki/The_C_Programming_Language)去了解更多.一篇关于如何自动检测和纠正这些问题的很酷的现代[论文](https://people.cs.umass.edu/~emery/pubs/pldi028-novark.pdf);这篇论文也包含了一些常见错误的很好总结和怎样发现并且修复他们提供了一些很棒的想法
